from rest_framework_simplejwt.exceptions import InvalidToken
from rest_framework_simplejwt.authentication import JWTTokenUserAuthentication
import jwt
import os
import structlog
import dotenv
from cryptography.hazmat.backends import default_backend
from cryptography import x509
from sentry_sdk import configure_scope

logger = structlog.getLogger("opers")

PUB_KEY_ENV = os.getenvb(b"JWTPUBKEY").replace(b"\\n", b"\n")
PUB_KEY_ENV = PUB_KEY_ENV.lstrip(b'"').rstrip(b'"')


def get_public_key_from_certificate(certificate_content: bytes) -> bytes:
    """
    Given a public signing certificate (e.g. downloaded from Auth0),
    load the certificate and then return the public key for it.

    :param certificate_content: The content of a public signing certificate in PEM format.
    :return: The public key.
    """
    certificate = x509.load_pem_x509_certificate(
        certificate_content, backend=default_backend()
    )

    return certificate.public_key()


PUBLIC_KEY = get_public_key_from_certificate(PUB_KEY_ENV)
#print(PUBLIC_KEY)



def decode_access_token(access_token: str) -> dict:
    """
    Verify a JWT access token generated by Auth0, and return its decoded content.
    """

    return jwt.decode(
        access_token,
        PUBLIC_KEY,
        algorithms=["RS256"],
        verify=True,
    )


class BankingAuthentication(JWTTokenUserAuthentication):
    def get_validated_token(self, raw_token):
        """
        Validates an encoded JSON web token and returns a validated token
        wrapper object.
        """
        messages = []
        try:
            return decode_access_token(raw_token)
        except Exception as e:
            messages.append(
                {"token_class": "mytoken", "token_type": "access", "message": e.args[0]}
            )

        raise InvalidToken(
            {
                "detail": "Given token not valid for any token type",
                "messages": messages,
            }
        )

    def authenticate(self, request):
        try:
            user, auth = super().authenticate(request)
        except TypeError:
            return None

        c_id = user.token.get("customer_external_id")
        user.id = c_id

        with configure_scope() as scope:
            scope.user = {"id": c_id}

        logger.bind(id=c_id)

        return user, auth

